{
  "code": "var Point = Laya.Point;\r\nexport class MathU {\r\n    constructor() {\r\n    }\r\n    static randomRange(min, max) {\r\n        var range = Math.floor((max - min + 1) * Math.random());\r\n        return range + min;\r\n    }\r\n    static randomRangeArr(min, max, count) {\r\n        let n = [];\r\n        for (var i = min; i < max; i++) {\r\n            n.push(i);\r\n        }\r\n        n.sort(function () {\r\n            return 0.5 - Math.random();\r\n        });\r\n        n.length = count;\r\n        return n;\r\n    }\r\n    static randomRangeNum(min, max, num) {\r\n        let n = [];\r\n        for (var i = min; i < max; i++) {\r\n            if (i != num)\r\n                n.push(i);\r\n        }\r\n        n.sort(function () {\r\n            return 0.5 - Math.random();\r\n        });\r\n        return n[0];\r\n    }\r\n    static randomRangeArr2(min, max, arr) {\r\n        let n = [];\r\n        for (var i = min; i < max; i++) {\r\n            if (arr.indexOf(i) == -1)\r\n                n.push(i);\r\n        }\r\n        n.sort(function () {\r\n            return 0.5 - Math.random();\r\n        });\r\n        return n[0];\r\n    }\r\n    static randomPointInCicle(centerPoint, radiusMin, radiusMax) {\r\n        let randomRad = MathU.randomRange(radiusMin, radiusMax);\r\n        let randomAngle = Math.random() * 360;\r\n        let resultPoint = new Point();\r\n        resultPoint.x = centerPoint.x + Math.sin(randomAngle * Math.PI / 180) * randomRad;\r\n        resultPoint.y = centerPoint.y + Math.cos(randomAngle * Math.PI / 180) * randomRad;\r\n        return resultPoint;\r\n    }\r\n    static parseInt(v) {\r\n        if (v >= 0) {\r\n            return Math.floor(v);\r\n        }\r\n        else {\r\n            return Math.ceil(v);\r\n        }\r\n    }\r\n    static getDistance(srcX, srcY, dstX, dstY) {\r\n        var x = srcX - dstX;\r\n        var y = srcY - dstY;\r\n        return Math.sqrt(x * x + y * y);\r\n    }\r\n    static getAngleTimeT(duration) {\r\n        return Number((Laya.timer.currTimer % duration) / duration) * Math.PI;\r\n    }\r\n    static getAngleByRotaion(rotation) {\r\n        rotation %= rotation;\r\n        return Math.PI * Number(rotation / 180);\r\n    }\r\n    static getAngle(srcX, srcY, dstX, dstY) {\r\n        dstX -= srcX;\r\n        dstY -= srcY;\r\n        var ang = Math.atan2(dstY, dstX);\r\n        ang = (ang >= 0) ? ang : 2 * Math.PI + ang;\r\n        return ang;\r\n    }\r\n    static getRotation(angle) {\r\n        return Math.round(Number(angle / Math.PI) * 180);\r\n    }\r\n    static randomBoolen() {\r\n        return Math.round(Math.random()) == 0;\r\n    }\r\n    static colorMatrix_adjust(contrast, brightness) {\r\n        let s = contrast + 1;\r\n        let o = 128 * (1 - s);\r\n        let aMatrix = [s, 0, 0, 0, o,\r\n            0, s, 0, 0, o,\r\n            0, 0, s, 0, o,\r\n            0, 0, 0, 1, 0];\r\n        brightness *= 255;\r\n        let bMatrix = [1, 0, 0, 0, brightness,\r\n            0, 1, 0, 0, brightness,\r\n            0, 0, 1, 0, brightness,\r\n            0, 0, 0, 1, 0];\r\n        return MathU.colorMatrix_concat(aMatrix, bMatrix);\r\n    }\r\n    static colorMatrix_concat(matrixa, matrixb) {\r\n        let sMatrix = new Array(20);\r\n        var i = 0;\r\n        for (var y = 0; y < 4; ++y) {\r\n            for (var x = 0; x < 5; ++x) {\r\n                sMatrix[i + x] = matrixa[i] * matrixb[x] +\r\n                    matrixa[i + 1] * matrixb[x + 5] +\r\n                    matrixa[i + 2] * matrixb[x + 10] +\r\n                    matrixa[i + 3] * matrixb[x + 15] +\r\n                    (x == 4 ? matrixa[i + 4] : 0);\r\n            }\r\n            i += 5;\r\n        }\r\n        return sMatrix;\r\n    }\r\n    static toHex(num) {\r\n        let rs = \"\";\r\n        let temp;\r\n        while (num / 16 > 0) {\r\n            temp = num % 16;\r\n            rs = (temp + \"\").replace(\"10\", \"a\").replace(\"11\", \"b\").replace(\"12\", \"c\").replace(\"13\", \"d\").replace(\"14\", \"e\").replace(\"15\", \"f\") + rs;\r\n            num = Math.floor(num / 16);\r\n        }\r\n        return rs;\r\n    }\r\n    static getRadiusByBox(width, height) {\r\n        let doubleW = Math.pow(width, 2);\r\n        let doubleH = Math.pow(height, 2);\r\n        let radius = Math.sqrt(doubleH + doubleW) / 2;\r\n        return radius;\r\n    }\r\n    static lerp(a, b, t) {\r\n        let c = 0;\r\n        c = a + t * (b - a);\r\n        return c;\r\n    }\r\n    static clearUpReward(arr) {\r\n        let info = [];\r\n        for (let i = 0; i < arr.length / 2; i++) {\r\n            let flag = false;\r\n            let key = arr[i * 2];\r\n            let value = arr[i * 2 + 1];\r\n            for (let j = 0; j < info.length; j++) {\r\n                if (info[j * 2] == key) {\r\n                    info[j * 2 + 1] += value;\r\n                    flag = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!flag) {\r\n                info.push(key);\r\n                info.push(value);\r\n            }\r\n        }\r\n        return info;\r\n    }\r\n}\r\nMathU.kTowardCount = 8;\r\n",
  "references": []
}
